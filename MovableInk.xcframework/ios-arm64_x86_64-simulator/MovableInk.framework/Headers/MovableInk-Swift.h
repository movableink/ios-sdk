#if 0
#elif defined(__arm64__) && __arm64__
// Generated by Apple Swift version 5.9.2 (swiftlang-5.9.2.2.56 clang-1500.1.0.2.5)
#ifndef MOVABLEINK_SWIFT_H
#define MOVABLEINK_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#if defined(__OBJC__)
#include <Foundation/Foundation.h>
#endif
#if defined(__cplusplus)
#include <cstdint>
#include <cstddef>
#include <cstdbool>
#include <cstring>
#include <stdlib.h>
#include <new>
#include <type_traits>
#else
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#endif
#if defined(__cplusplus)
#if defined(__arm64e__) && __has_include(<ptrauth.h>)
# include <ptrauth.h>
#else
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreserved-macro-identifier"
# ifndef __ptrauth_swift_value_witness_function_pointer
#  define __ptrauth_swift_value_witness_function_pointer(x)
# endif
# ifndef __ptrauth_swift_class_method_pointer
#  define __ptrauth_swift_class_method_pointer(x)
# endif
#pragma clang diagnostic pop
#endif
#endif

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...) 
# endif
#endif
#if !defined(SWIFT_RUNTIME_NAME)
# if __has_attribute(objc_runtime_name)
#  define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
# else
#  define SWIFT_RUNTIME_NAME(X) 
# endif
#endif
#if !defined(SWIFT_COMPILE_NAME)
# if __has_attribute(swift_name)
#  define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
# else
#  define SWIFT_COMPILE_NAME(X) 
# endif
#endif
#if !defined(SWIFT_METHOD_FAMILY)
# if __has_attribute(objc_method_family)
#  define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
# else
#  define SWIFT_METHOD_FAMILY(X) 
# endif
#endif
#if !defined(SWIFT_NOESCAPE)
# if __has_attribute(noescape)
#  define SWIFT_NOESCAPE __attribute__((noescape))
# else
#  define SWIFT_NOESCAPE 
# endif
#endif
#if !defined(SWIFT_RELEASES_ARGUMENT)
# if __has_attribute(ns_consumed)
#  define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
# else
#  define SWIFT_RELEASES_ARGUMENT 
# endif
#endif
#if !defined(SWIFT_WARN_UNUSED_RESULT)
# if __has_attribute(warn_unused_result)
#  define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
# else
#  define SWIFT_WARN_UNUSED_RESULT 
# endif
#endif
#if !defined(SWIFT_NORETURN)
# if __has_attribute(noreturn)
#  define SWIFT_NORETURN __attribute__((noreturn))
# else
#  define SWIFT_NORETURN 
# endif
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA 
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA 
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA 
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif
#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif
#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER 
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility) 
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED_OBJC)
# if __has_feature(attribute_diagnose_if_objc)
#  define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
# else
#  define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
# endif
#endif
#if defined(__OBJC__)
#if !defined(IBSegueAction)
# define IBSegueAction 
#endif
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if !defined(SWIFT_CALL)
# define SWIFT_CALL __attribute__((swiftcall))
#endif
#if !defined(SWIFT_INDIRECT_RESULT)
# define SWIFT_INDIRECT_RESULT __attribute__((swift_indirect_result))
#endif
#if !defined(SWIFT_CONTEXT)
# define SWIFT_CONTEXT __attribute__((swift_context))
#endif
#if !defined(SWIFT_ERROR_RESULT)
# define SWIFT_ERROR_RESULT __attribute__((swift_error_result))
#endif
#if defined(__cplusplus)
# define SWIFT_NOEXCEPT noexcept
#else
# define SWIFT_NOEXCEPT 
#endif
#if !defined(SWIFT_C_INLINE_THUNK)
# if __has_attribute(always_inline)
# if __has_attribute(nodebug)
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline)) __attribute__((nodebug))
# else
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline))
# endif
# else
#  define SWIFT_C_INLINE_THUNK inline
# endif
#endif
#if defined(_WIN32)
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL __declspec(dllimport)
#endif
#else
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL 
#endif
#endif
#if defined(__OBJC__)
#if __has_feature(objc_modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import Foundation;
@import ObjectiveC;
@import UIKit;
#endif

#endif
#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="MovableInk",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

#if defined(__OBJC__)

@class NSString;
@class NSError;

/// MIClient provides all the tools to coerce a MovableInk Link into a clickthrough link and to deeplink.
SWIFT_CLASS("_TtC10MovableInk8MIClient")
@interface MIClient : NSObject
/// This is the deeplink that the sdk resolved last.
/// This could be used to navigate to a deeplink after login for example.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nullable storedDeeplink;)
+ (NSString * _Nullable)storedDeeplink SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// The entry point for the MovableInk SDK.  You should call this method from within
/// your AppDelegates <code>application(_:didFinishLaunchingWithOption:)</code> method.
/// \param apiKey The API Key for Behavior Events. If this is nil, the SDK will attempt to load the key from the plist.
///
/// \param deeplinkDomains The list of domains you’d like the SDK to handle for incoming universal links.
///
/// \param launchOptions The launch options given at app boot.
///
/// \param result The closure that will be called when the MovableInk SDK finds a DeepLink
/// that it can handle and has decoded the link into the clickthrough link.
///
+ (void)startWithApiKey:(NSString * _Nullable)apiKey deeplinkDomains:(NSArray<NSString *> * _Nonnull)deeplinkDomains launchOptions:(NSDictionary<UIApplicationLaunchOptionsKey, id> * _Nullable)launchOptions result:(void (^ _Nonnull)(NSString * _Nullable, NSError * _Nullable))result;
@end



@interface MIClient (SWIFT_EXTENSION(MovableInk))
/// Shows an InAppMessage for an MI Link
/// \param link The MI Content Link (.html) to use
///
/// \param hideCloseButton Set to true to hide the close button.
///
/// \param handler The handler that will be called containing the buttonID that was tapped. If no buttonID was found for any links that
/// were interacted with, this will not be called.
///
+ (void)showInAppMessageWith:(id _Nonnull)link hideCloseButton:(BOOL)hideCloseButton handler:(void (^ _Nonnull)(NSString * _Nonnull))handler;
@end


@interface MIClient (SWIFT_EXTENSION(MovableInk))
/// The current mi_u value set in the SDK
+ (NSString * _Nullable)miU SWIFT_WARN_UNUSED_RESULT;
/// Set the mi_u for the user. You should call this after the user has logged in and you are aware of the mi_u.
/// \param value The new mi_u value to save.
///
+ (void)setMIU:(NSString * _Nonnull)value;
@end

@class ProductProperties;
@class OrderCompletedProperties;
@class ProductCategory;
@class ProductSearchedProperties;

@interface MIClient (SWIFT_EXTENSION(MovableInk))
/// Tracks a product viewed event
/// The dictionary <em>must</em> have an <em>id</em> key where it’s value is a String or Int. If the <em>id</em> is missing or invalid, the event will not be tracked.
/// This method will attempt to extract the <em>id</em>, <em>title</em>, <em>price</em>, <em>url</em>, and <em>categories</em> keys.
/// All other keys will be used to build the <code>meta</code> property on this object.
/// Example of a dictionary that could be provided to this method:
/// \code
/// [
///   "id": 1,
///   "title": "Hyperion",
///   "price": 18.99,
///   "url": "https://inkrediblebooks.com/hyperion-dan-simmons",
///   "categories": [
///     [ "id": "Sci-Fi", "url": "https://inkrediblebooks.com/categories/scifi" ],
///     [ "id": "Fiction", "url": "https://inkrediblebooks.com/categories/fiction" ]
///   ],
///   "pages": 496
/// ]
///
/// \endcode\param dict The properties for the product
///
+ (void)productViewed:(NSDictionary<NSString *, id> * _Nonnull)dict;
/// Tracks a product viewed event
/// \param properties The properties for the product
///
+ (void)productViewedWithProperties:(ProductProperties * _Nonnull)properties;
/// Tracks a product added event
/// The dictionary <em>must</em> have an <em>id</em> key where it’s value is a String or Int. If the <em>id</em> is missing or invalid, the event will not be tracked.
/// This method will attempt to extract the <em>id</em>, <em>title</em>, <em>price</em>, <em>url</em>, and <em>categories</em> keys.
/// All other keys will be used to build the <code>meta</code> property on this object.
/// Example of a dictionary that could be provided to this method:
/// \code
/// [
///   "id": 1,
///   "title": "Hyperion",
///   "price": "18.99",
///   "url": "https://inkrediblebooks.com/hyperion-dan-simmons",
///   "categories": [
///     [ "id": "Sci-Fi", "url": "https://inkrediblebooks.com/categories/scifi" ],
///     [ "id": "Fiction", "url": "https://inkrediblebooks.com/categories/fiction" ]
///   ],
///   "pages": 496
/// ]
///
/// \endcode\param dict The properties for the product
///
+ (void)productAdded:(NSDictionary<NSString *, id> * _Nonnull)dict;
/// Tracks a product added event
/// \param properties The properties for the product
///
+ (void)productAddedWithProperties:(ProductProperties * _Nonnull)properties;
/// Tracks a product removed event
/// The dictionary <em>must</em> have an <em>id</em> key where it’s value is a String or Int. If the <em>id</em> is missing or invalid, the event will not be tracked.
/// This method will attempt to extract the <em>id</em>, <em>title</em>, <em>price</em>, <em>url</em>, and <em>categories</em> keys.
/// All other keys will be used to build the <code>meta</code> property on this object.
/// Example of a dictionary that could be provided to this method:
/// \code
/// [
///   "id": 1,
///   "title": "Hyperion",
///   "price": "18.99",
///   "url": "https://inkrediblebooks.com/hyperion-dan-simmons",
///   "categories": [
///     [ "id": "Sci-Fi", "url": "https://inkrediblebooks.com/categories/scifi" ],
///     [ "id": "Fiction", "url": "https://inkrediblebooks.com/categories/fiction" ]
///   ],
///   "pages": 496
/// ]
///
/// \endcode\param dict The properties for the product
///
+ (void)productRemoved:(NSDictionary<NSString *, id> * _Nonnull)dict;
/// Tracks a product removed event
/// \param properties The properties for the product
///
+ (void)productRemovedWithProperties:(ProductProperties * _Nonnull)properties;
/// Tracks an order completed
/// The dictionary <em>must</em> have a <em>products</em> key as an array, and optionally an <em>id</em> (Int or String) and <em>revenue</em> (Float) keys.
/// Example of a dictionary that could be provided to this method:
/// \code
/// [
///   "id": 1,
///   "revenue": 18.99,
///   "products": [
///     [
///       "title": "Hyperion",
///       "price": 18.99,
///       "quantity": 1,
///       "id": "1",
///       "url": "https://inkrediblebooks.com/hyperion-dan-simmons"
///     ]
///   ]
/// ]
///
/// \endcode\param dict The properties for the product
///
+ (void)orderCompleted:(NSDictionary<NSString *, id> * _Nonnull)dict;
/// Tracks a product added event
/// \param properties The properties for the product
///
+ (void)orderCompletedWithProperties:(OrderCompletedProperties * _Nonnull)properties;
/// Tracks a category viewed event
/// The dictionary <em>must</em> have an <em>id</em> key where it’s value is a String or Int. If the <em>id</em> is missing or invalid, the event will not be tracked.
/// This method will attempt to extract the <em>id</em>, <em>title</em>, and <em>url</em> keys.
/// All other keys will be ignored.
/// Example of a dictionary that could be provided to this method:
/// \code
/// [
///   "id": "mens",
///   "title": "Mens",
///   "url": "https://inkrediblebooks.com/categories/mens"
/// ]
///
/// \endcode\param dict The categories as a dictionary
///
+ (void)categoryViewed:(NSDictionary<NSString *, id> * _Nonnull)dict;
/// Tracks a category viewed event
/// \param category The category to track
///
+ (void)categoryViewedWithCategory:(ProductCategory * _Nonnull)category;
/// Tracks a category viewed event
/// The dictionary <em>must</em> have  <em>query</em> key where it’s value is a String. If the <em>query</em> is missing or invalid, the event will not be tracked.
/// This method will attempt to extract the <em>query</em> and <em>url</em> keys.
/// All other keys will be ignored.
/// Example of a dictionary that could be provided to this method:
/// \code
/// [
///   "query": "hyperion",
///   "url": "https://inkrediblebooks.com/search?q=hyperion"
/// ]
///
/// \endcode\param dict The categories as a dictionary
///
+ (void)productSearched:(NSDictionary<NSString *, id> * _Nonnull)dict;
/// Tracks a product searched event.
/// \param properties The properties for the event
///
+ (void)productSearchedWithProperties:(ProductSearchedProperties * _Nonnull)properties;
/// Attempts to associate events from an anonymous user to the current user.
+ (void)identifyUser:(NSString * _Nonnull)id;
/// Attempts to associate events from an anonymous user to the current user.
/// If you track events without an miu being set, you can later associate those events to a user once they become known.
/// For example, a user uses your app as a guest and you track events. At some point you prompt the user to sign up,
/// and they do. You should call <code>MIClient.setMIU(_:)</code> with the users id, then call <code>MIClient.identifyUser()</code>.
/// note: - This method will attempt to use the current miu value that was previously set via a deeplink or manually by the client
+ (void)identifyUser;
/// Logs a custom event
/// note:
/// Any String in the properties should not exceed 512 characters. Arrays may only contain up to 20 items.
+ (void)logEventWithName:(NSString * _Nonnull)name properties:(NSDictionary<NSString *, id> * _Nonnull)properties;
@end

@class NSURL;
@class NSItemProvider;
@class UISceneConnectionOptions;
@class NSUserActivity;

@interface MIClient (SWIFT_EXTENSION(MovableInk))
/// Checks the Pasteboard to see if there is a URL on it that the SDK can handle when the app is first installed.
/// You should call this if you are utilizing Deferred Deeplinking. Make sure to call this after <code>MIClient.start</code> has
/// been called. You can however, call this anytime you feel is correct for your apps flow (after login / signup) as long
/// <code>MIClient.start</code> has been called. The closure provided when calling start will be called if a link that could be
/// handled was found.
/// If running on iOS 16+, this will prompt the user for permission to read from the pasteboard.
/// If you wish, you can check if your running on iOS 16+ prior to calling this method and let the user know to
/// accept the permission.
/// If you wish to not show the prompt, you can choose to use UIPasteControl instead. If you choose this route, you must
/// set the pasteConfiguration to
/// <code>UIPasteConfiguration(acceptableTypeIdentifiers: [UTType.url.identifier, UTType.text.identifier])</code>.
/// Call <code>MIClient.paste(itemProviders:)</code> from your <code>paste(itemProviders:)</code> method.
/// warning:
/// Do not use both <code>checkPasteboardOnInstall</code> and <code>paste(itemProviders:)</code>
+ (void)checkPasteboardOnInstall;
/// Checks the Pasteboard to see if there is a URL on it that the SDK can handle when the app is first installed.
/// You should call this if you are utilizing Deferred Deeplinking. Make sure to call this after <code>MIClient.start</code> has
/// been called. You can however, call this anytime you feel is correct for your apps flow (after login / signup) as long
/// <code>MIClient.start</code> has been called. This method will not call the closure provided when calling start, but instead
/// will return the resolved url if one was found.
/// If running on iOS 16+, this will prompt the user for permission to read from the pasteboard.
/// If you wish, you can check if your running on iOS 16+ prior to calling this method and let the user know to
/// accept the permission.
/// If you wish to not show the prompt, you can choose to use UIPasteControl instead. If you choose this route, you must
/// set the pasteConfiguration to
/// <code>UIPasteConfiguration(acceptableTypeIdentifiers: [UTType.url.identifier, UTType.text.identifier])</code>.
/// Call <code>MIClient.paste(itemProviders:)</code> from your <code>paste(itemProviders:)</code> method.
/// warning:
/// Do not use both <code>checkPasteboardOnInstall</code> and <code>paste(itemProviders:)</code>
+ (void)checkPasteboardOnInstallWithCompletionHandler:(void (^ _Nonnull)(NSURL * _Nullable))completionHandler;
/// Allows you to send pasted ItemProviders from a UIPasteControl into the SDK to check for deeplinks.
/// If running on iOS 16+, and you wish to not show the paste prompt (checkPasteboardOnInstall);
/// you can choose to use UIPasteControl instead.
/// If you choose this route, you must set the pasteConfiguration to
/// <code>UIPasteConfiguration(acceptableTypeIdentifiers: [UTType.url.identifier, UTType.text.identifier])</code>.
/// Call <code>MIClient.paste(itemProviders:)</code> from your <code>paste(itemProviders:)</code> method.
/// \code
/// override func paste(itemProviders: [NSItemProvider]) {
///   if #available(iOS 16, *) {
///     MIClient.paste(itemProviders: itemProviders)
///   }
/// }
///
/// \endcodeMake sure that <code>MIClient.start</code> has been called before invoking this method.
/// If you need to know if the SDK found a link that could be handled, use the async version of this method instead.
/// warning:
/// Do not use both <code>checkPasteboardOnInstall</code> and <code>paste(itemProviders:)</code>
+ (void)pasteWithItemProviders:(NSArray<NSItemProvider *> * _Nonnull)itemProviders SWIFT_AVAILABILITY(ios,introduced=16);
/// Allows you to send pasted ItemProviders from a UIPasteControl into the SDK to check for deeplinks returning if
/// the SDK found a link that it could handle.
/// If running on iOS 16+, and you wish to not show the paste prompt (checkPasteboardOnInstall);
/// you can choose to use UIPasteControl instead.
/// If you choose this route, you must set the pasteConfiguration to
/// <code>UIPasteConfiguration(acceptableTypeIdentifiers: [UTType.url.identifier, UTType.text.identifier])</code>.
/// Call <code>await MIClient.paste(itemProviders:)</code> from your <code>paste(itemProviders:)</code> method.
/// \code
/// override func paste(itemProviders: [NSItemProvider]) {
///   if #available(iOS 16, *) {
///     Task {
///       let canHandle = await MIClient.paste(itemProviders: itemProviders)
///       // If canHandle is true, the SDK did find a url that it could handle
///       // You can use this to notify the user that the check was successful
///     }
///   }
/// }
///
/// \endcodeMake sure that <code>MIClient.start</code> has been called before invoking this method.
/// warning:
/// Do not use both <code>checkPasteboardOnInstall</code> and <code>paste(itemProviders:)</code>
+ (void)pasteWithItemProviders:(NSArray<NSItemProvider *> * _Nonnull)itemProviders completionHandler:(void (^ _Nonnull)(BOOL))completionHandler SWIFT_AVAILABILITY(ios,introduced=16);
/// Set the paths that the SDK should handle for a given domain.
/// By default, any domains that you ask the MovableInk SDK to handle via the <em>movable_ink_universal_link_domains</em> plist key will allow all paths.
/// If you need to restrict the paths that the SDK should handle, you can set them here. Make sure to only supply domains that you want to restrict.
/// You can supply a dictionary to tell the SDK to handle all paths for the <em>mycustomdomain.com</em> that contain
/// paths with <em>/products/ANY_NUMBER_OF_DIGITS</em>
/// Example
/// \code
/// ["mycustomdomain.com": ["/product/\d+"]]
///
/// \endcodeThe dictionary should contain the domain as a key and the value as an array of regex strings.
/// note:
/// If you call this multiple times with the same domain, the new values will overwrite the old values.
/// warning:
/// It’s a developer error to add your MovableInk domains here.
/// \param options The dictionary of domains and paths
///
+ (void)addHandleablePaths:(NSDictionary<NSString *, NSArray<NSString *> *> * _Nonnull)options;
/// Remove a domain from the handleable paths.
/// \param domain The domain to remove from the handleable paths
///
+ (void)removeHandleablePathsFor:(NSString * _Nonnull)domain;
+ (void)clearHandleablePaths;
/// Register a a list of domains as a deeplink.
/// This should only be the domain of the URL, not the entire URL, i.e: mi.example.com not https://mi.example.com
/// note:
/// You usually wont need to manually call this method yourself as the SDK will do it for you when
/// it attempts to load the domains from your Info.plist. Only call this method yourself if you need to tell the SDK
/// to handle links that you are unaware of at build time.
/// \param domains A list of domains to register with the SDK.
///
+ (void)registerDeeplinkDomains:(NSArray<NSString *> * _Nonnull)domains;
/// Checks a given URL if MovableInk can handle it as a deeplink.
/// \param url A URL to check
///
///
/// returns:
/// True if the URL can be handled by MovableInk, otherwise false.
+ (BOOL)canHandleURL:(NSURL * _Nonnull)url SWIFT_WARN_UNUSED_RESULT;
/// Call this method to handle a Universal Link from incoming UIScene.ConnectionOptions
/// If your application does support Scenes, you should call this method from within
/// your SceneDelegates <code>scene(_:willConnectTo:options:)</code> method. You must also call <code>handleUniversalLink(from:)</code> from the
/// <code>scene(_:continue:)</code> method as well.
/// If your application does <em>not</em> support Scenes, you should utilize <code>handleUniversalLink(from:)</code> method instead.
/// \param options The UIScene.ConnectionOptions
///
+ (BOOL)handleUniversalLinkWith:(UISceneConnectionOptions * _Nonnull)options;
/// Call this method to handle a Universal Link from an incoming NSUserActivity
/// If your application does <em>not</em> support Scenes, you should call this method from within
/// your AppDelegates  <code>application(_:continue:restorationHandler:)</code> method.
/// If your application does support Scenes, you should call this method from within your SceneDelegates <code>scene(_:continue:)</code> method and also
/// should utilize the <code>handleUniversalLink(with:)</code> method.
/// \param userActivity The NSUserActivity Object
///
///
/// returns:
/// True if MIClient can handle the Universal Link, otherwise false.
+ (BOOL)handleUniversalLinkFrom:(NSUserActivity * _Nonnull)userActivity;
/// Call this method to handle a Universal Link from incoming URL.
/// You should call this method in <code>application(_:,open:,options:)</code> method in the AppDelegate or
/// in the <code>onOpenURL</code> modifier for SwiftUI Apps.
/// You can also call this from anywhere else in your app if you need to resolve a link that wasn’t opened via a
/// universal link but still want to process as a Universal Link.
/// \param url A URL to resolve
///
///
/// returns:
/// True if MIClient can handle the Universal Link, otherwise false.
+ (BOOL)handleUniversalLinkWithUrl:(NSURL * _Nonnull)url;
/// Manually resolve a MovableInk Link or some other link, such as an ESP Link, that you want to want to resolve.
/// note:
/// The domain of the url must be registered with the SDK via the plist or <code>registerDeeplinkDomains(_:)</code> prior to this call.
/// warning:
/// Using this method will NOT call the <code>start(launchOptions:deeplinkHandler:)</code> closure.
/// The <code>storedDeeplinkSubject</code> will also NOT be set when using this method.
/// \param url The URL to resolve
///
///
/// returns:
/// The clickthrough URL or nil if there was an error.
+ (void)resolveWithUrl:(NSURL * _Nonnull)url completionHandler:(void (^ _Nonnull)(NSURL * _Nullable, NSError * _Nullable))completionHandler;
@end




SWIFT_CLASS("_TtC10MovableInk21OrderCompletedProduct")
@interface OrderCompletedProduct : NSObject
@property (nonatomic, readonly, copy) NSString * _Nonnull id;
@property (nonatomic, readonly, copy) NSString * _Nullable title;
@property (nonatomic, readonly, copy) NSURL * _Nullable url;
@property (nonatomic, readonly, copy) NSString * _Nullable price;
- (nonnull instancetype)initWithId:(NSString * _Nonnull)id title:(NSString * _Nullable)title price:(NSDecimal)price url:(NSURL * _Nullable)url quantity:(NSInteger)quantity OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithDict:(NSDictionary<NSString *, id> * _Nonnull)dict OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC10MovableInk24OrderCompletedProperties")
@interface OrderCompletedProperties : NSObject
@property (nonatomic, readonly, copy) NSString * _Nullable id;
@property (nonatomic, readonly, copy) NSString * _Nullable revenue;
@property (nonatomic, readonly, copy) NSArray<OrderCompletedProduct *> * _Nonnull products;
- (nonnull instancetype)initWithId:(NSString * _Nullable)id stringRevenue:(NSString * _Nullable)revenue products:(NSArray<OrderCompletedProduct *> * _Nonnull)products OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithId:(NSString * _Nullable)id floatRevenue:(float)revenue products:(NSArray<OrderCompletedProduct *> * _Nonnull)products OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithId:(NSString * _Nullable)id doubleRevenue:(double)revenue products:(NSArray<OrderCompletedProduct *> * _Nonnull)products OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithId:(NSString * _Nullable)id intRevenue:(NSInteger)revenue products:(NSArray<OrderCompletedProduct *> * _Nonnull)products OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithId:(NSString * _Nullable)id decimalRevenue:(NSDecimal)revenue products:(NSArray<OrderCompletedProduct *> * _Nonnull)products OBJC_DESIGNATED_INITIALIZER;
/// Create an instance from a dictionary
/// The dictionary <em>must</em> have an <em>id</em> key where it’s value is a String or Int. If the <em>id</em> is missing or invalid, this will return nil.
/// This method will attempt to extract the <em>id</em>, <em>title</em>, <em>price</em>, <em>url</em>, and <em>categories</em> keys.
/// All other keys will be used to build the <code>meta</code> property on this object.
/// Example of a dictionary that could be provided to this method:
/// \code
/// [
///  "id": 1,
///  "title": "Hyperion",
///  "price": "18.99",
///  "url": "https://inkrediblebooks.com/hyperion-dan-simmons",
///  "categories": [
///    [ "id": "Sci-Fi", "url": "https://inkrediblebooks.com/categories/scifi" ],
///    [ "id": "Fiction", "url": "https://inkrediblebooks.com/categories/fiction" ]
///  ],
///  "pages": 496
/// ]
///
/// \endcode
- (nullable instancetype)initWithDict:(NSDictionary<NSString *, id> * _Nonnull)dict OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC10MovableInk15ProductCategory")
@interface ProductCategory : NSObject
@property (nonatomic, readonly, copy) NSString * _Nonnull id;
@property (nonatomic, readonly, copy) NSString * _Nullable title;
@property (nonatomic, readonly, copy) NSURL * _Nullable url;
- (nonnull instancetype)initWithId:(NSString * _Nonnull)id title:(NSString * _Nullable)title url:(NSURL * _Nullable)url OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithDict:(NSDictionary<NSString *, id> * _Nonnull)dict OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC10MovableInk17ProductProperties")
@interface ProductProperties : NSObject
@property (nonatomic, readonly, copy) NSString * _Nonnull id;
@property (nonatomic, readonly, copy) NSString * _Nullable title;
@property (nonatomic, readonly, copy) NSString * _Nullable price;
@property (nonatomic, readonly, copy) NSURL * _Nullable url;
@property (nonatomic, readonly, copy) NSArray<ProductCategory *> * _Nullable categories;
@property (nonatomic, readonly, copy) NSDictionary<NSString *, id> * _Nullable meta;
- (nonnull instancetype)initWithId:(NSString * _Nonnull)id title:(NSString * _Nullable)title stringPrice:(NSString * _Nullable)price url:(NSURL * _Nullable)url categories:(NSArray<ProductCategory *> * _Nullable)categories meta:(NSDictionary<NSString *, id> * _Nullable)meta OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithId:(NSString * _Nonnull)id title:(NSString * _Nullable)title floatPrice:(float)price url:(NSURL * _Nullable)url categories:(NSArray<ProductCategory *> * _Nullable)categories meta:(NSDictionary<NSString *, id> * _Nullable)meta OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithId:(NSString * _Nonnull)id title:(NSString * _Nullable)title doublePrice:(double)price url:(NSURL * _Nullable)url categories:(NSArray<ProductCategory *> * _Nullable)categories meta:(NSDictionary<NSString *, id> * _Nullable)meta OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithId:(NSString * _Nonnull)id title:(NSString * _Nullable)title intPrice:(NSInteger)price url:(NSURL * _Nullable)url categories:(NSArray<ProductCategory *> * _Nullable)categories meta:(NSDictionary<NSString *, id> * _Nullable)meta OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithId:(NSString * _Nonnull)id title:(NSString * _Nullable)title decimalPrice:(NSDecimal)price url:(NSURL * _Nullable)url categories:(NSArray<ProductCategory *> * _Nullable)categories meta:(NSDictionary<NSString *, id> * _Nullable)meta OBJC_DESIGNATED_INITIALIZER;
/// Create an instance from a dictionary
/// The dictionary <em>must</em> have an <em>id</em> key where it’s value is a String or Int. If the <em>id</em> is missing or invalid, this will return nil.
/// This method will attempt to extract the <em>id</em>, <em>title</em>, <em>price</em>, <em>url</em>, and <em>categories</em> keys.
/// All other keys will be used to build the <code>meta</code> property on this object.
/// Example of a dictionary that could be provided to this method:
/// \code
/// [
///  "id": 1,
///  "title": "Hyperion",
///  "price": 18.99,
///  "url": "https://inkrediblebooks.com/hyperion-dan-simmons",
///  "categories": [
///    [ "id": "Sci-Fi", "url": "https://inkrediblebooks.com/categories/scifi" ],
///    [ "id": "Fiction", "url": "https://inkrediblebooks.com/categories/fiction" ]
///  ],
///  "pages": 496
/// ]
///
/// \endcode
- (nullable instancetype)initWithDict:(NSDictionary<NSString *, id> * _Nonnull)dict OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC10MovableInk25ProductSearchedProperties")
@interface ProductSearchedProperties : NSObject
@property (nonatomic, readonly, copy) NSString * _Nonnull query;
@property (nonatomic, readonly, copy) NSURL * _Nullable url;
- (nonnull instancetype)initWithQuery:(NSString * _Nonnull)query url:(NSURL * _Nullable)url OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithDict:(NSDictionary<NSString *, id> * _Nonnull)dict OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end





#endif
#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#if defined(__cplusplus)
#endif
#pragma clang diagnostic pop
#endif

#elif defined(__x86_64__) && __x86_64__
// Generated by Apple Swift version 5.9.2 (swiftlang-5.9.2.2.56 clang-1500.1.0.2.5)
#ifndef MOVABLEINK_SWIFT_H
#define MOVABLEINK_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#if defined(__OBJC__)
#include <Foundation/Foundation.h>
#endif
#if defined(__cplusplus)
#include <cstdint>
#include <cstddef>
#include <cstdbool>
#include <cstring>
#include <stdlib.h>
#include <new>
#include <type_traits>
#else
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#endif
#if defined(__cplusplus)
#if defined(__arm64e__) && __has_include(<ptrauth.h>)
# include <ptrauth.h>
#else
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreserved-macro-identifier"
# ifndef __ptrauth_swift_value_witness_function_pointer
#  define __ptrauth_swift_value_witness_function_pointer(x)
# endif
# ifndef __ptrauth_swift_class_method_pointer
#  define __ptrauth_swift_class_method_pointer(x)
# endif
#pragma clang diagnostic pop
#endif
#endif

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...) 
# endif
#endif
#if !defined(SWIFT_RUNTIME_NAME)
# if __has_attribute(objc_runtime_name)
#  define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
# else
#  define SWIFT_RUNTIME_NAME(X) 
# endif
#endif
#if !defined(SWIFT_COMPILE_NAME)
# if __has_attribute(swift_name)
#  define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
# else
#  define SWIFT_COMPILE_NAME(X) 
# endif
#endif
#if !defined(SWIFT_METHOD_FAMILY)
# if __has_attribute(objc_method_family)
#  define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
# else
#  define SWIFT_METHOD_FAMILY(X) 
# endif
#endif
#if !defined(SWIFT_NOESCAPE)
# if __has_attribute(noescape)
#  define SWIFT_NOESCAPE __attribute__((noescape))
# else
#  define SWIFT_NOESCAPE 
# endif
#endif
#if !defined(SWIFT_RELEASES_ARGUMENT)
# if __has_attribute(ns_consumed)
#  define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
# else
#  define SWIFT_RELEASES_ARGUMENT 
# endif
#endif
#if !defined(SWIFT_WARN_UNUSED_RESULT)
# if __has_attribute(warn_unused_result)
#  define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
# else
#  define SWIFT_WARN_UNUSED_RESULT 
# endif
#endif
#if !defined(SWIFT_NORETURN)
# if __has_attribute(noreturn)
#  define SWIFT_NORETURN __attribute__((noreturn))
# else
#  define SWIFT_NORETURN 
# endif
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA 
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA 
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA 
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif
#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif
#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER 
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility) 
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if !defined(SWIFT_DEPRECATED_OBJC)
# if __has_feature(attribute_diagnose_if_objc)
#  define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
# else
#  define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
# endif
#endif
#if defined(__OBJC__)
#if !defined(IBSegueAction)
# define IBSegueAction 
#endif
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if !defined(SWIFT_CALL)
# define SWIFT_CALL __attribute__((swiftcall))
#endif
#if !defined(SWIFT_INDIRECT_RESULT)
# define SWIFT_INDIRECT_RESULT __attribute__((swift_indirect_result))
#endif
#if !defined(SWIFT_CONTEXT)
# define SWIFT_CONTEXT __attribute__((swift_context))
#endif
#if !defined(SWIFT_ERROR_RESULT)
# define SWIFT_ERROR_RESULT __attribute__((swift_error_result))
#endif
#if defined(__cplusplus)
# define SWIFT_NOEXCEPT noexcept
#else
# define SWIFT_NOEXCEPT 
#endif
#if !defined(SWIFT_C_INLINE_THUNK)
# if __has_attribute(always_inline)
# if __has_attribute(nodebug)
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline)) __attribute__((nodebug))
# else
#  define SWIFT_C_INLINE_THUNK inline __attribute__((always_inline))
# endif
# else
#  define SWIFT_C_INLINE_THUNK inline
# endif
#endif
#if defined(_WIN32)
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL __declspec(dllimport)
#endif
#else
#if !defined(SWIFT_IMPORT_STDLIB_SYMBOL)
# define SWIFT_IMPORT_STDLIB_SYMBOL 
#endif
#endif
#if defined(__OBJC__)
#if __has_feature(objc_modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import Foundation;
@import ObjectiveC;
@import UIKit;
#endif

#endif
#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="MovableInk",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

#if defined(__OBJC__)

@class NSString;
@class NSError;

/// MIClient provides all the tools to coerce a MovableInk Link into a clickthrough link and to deeplink.
SWIFT_CLASS("_TtC10MovableInk8MIClient")
@interface MIClient : NSObject
/// This is the deeplink that the sdk resolved last.
/// This could be used to navigate to a deeplink after login for example.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nullable storedDeeplink;)
+ (NSString * _Nullable)storedDeeplink SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
/// The entry point for the MovableInk SDK.  You should call this method from within
/// your AppDelegates <code>application(_:didFinishLaunchingWithOption:)</code> method.
/// \param apiKey The API Key for Behavior Events. If this is nil, the SDK will attempt to load the key from the plist.
///
/// \param deeplinkDomains The list of domains you’d like the SDK to handle for incoming universal links.
///
/// \param launchOptions The launch options given at app boot.
///
/// \param result The closure that will be called when the MovableInk SDK finds a DeepLink
/// that it can handle and has decoded the link into the clickthrough link.
///
+ (void)startWithApiKey:(NSString * _Nullable)apiKey deeplinkDomains:(NSArray<NSString *> * _Nonnull)deeplinkDomains launchOptions:(NSDictionary<UIApplicationLaunchOptionsKey, id> * _Nullable)launchOptions result:(void (^ _Nonnull)(NSString * _Nullable, NSError * _Nullable))result;
@end



@interface MIClient (SWIFT_EXTENSION(MovableInk))
/// Shows an InAppMessage for an MI Link
/// \param link The MI Content Link (.html) to use
///
/// \param hideCloseButton Set to true to hide the close button.
///
/// \param handler The handler that will be called containing the buttonID that was tapped. If no buttonID was found for any links that
/// were interacted with, this will not be called.
///
+ (void)showInAppMessageWith:(id _Nonnull)link hideCloseButton:(BOOL)hideCloseButton handler:(void (^ _Nonnull)(NSString * _Nonnull))handler;
@end


@interface MIClient (SWIFT_EXTENSION(MovableInk))
/// The current mi_u value set in the SDK
+ (NSString * _Nullable)miU SWIFT_WARN_UNUSED_RESULT;
/// Set the mi_u for the user. You should call this after the user has logged in and you are aware of the mi_u.
/// \param value The new mi_u value to save.
///
+ (void)setMIU:(NSString * _Nonnull)value;
@end

@class ProductProperties;
@class OrderCompletedProperties;
@class ProductCategory;
@class ProductSearchedProperties;

@interface MIClient (SWIFT_EXTENSION(MovableInk))
/// Tracks a product viewed event
/// The dictionary <em>must</em> have an <em>id</em> key where it’s value is a String or Int. If the <em>id</em> is missing or invalid, the event will not be tracked.
/// This method will attempt to extract the <em>id</em>, <em>title</em>, <em>price</em>, <em>url</em>, and <em>categories</em> keys.
/// All other keys will be used to build the <code>meta</code> property on this object.
/// Example of a dictionary that could be provided to this method:
/// \code
/// [
///   "id": 1,
///   "title": "Hyperion",
///   "price": 18.99,
///   "url": "https://inkrediblebooks.com/hyperion-dan-simmons",
///   "categories": [
///     [ "id": "Sci-Fi", "url": "https://inkrediblebooks.com/categories/scifi" ],
///     [ "id": "Fiction", "url": "https://inkrediblebooks.com/categories/fiction" ]
///   ],
///   "pages": 496
/// ]
///
/// \endcode\param dict The properties for the product
///
+ (void)productViewed:(NSDictionary<NSString *, id> * _Nonnull)dict;
/// Tracks a product viewed event
/// \param properties The properties for the product
///
+ (void)productViewedWithProperties:(ProductProperties * _Nonnull)properties;
/// Tracks a product added event
/// The dictionary <em>must</em> have an <em>id</em> key where it’s value is a String or Int. If the <em>id</em> is missing or invalid, the event will not be tracked.
/// This method will attempt to extract the <em>id</em>, <em>title</em>, <em>price</em>, <em>url</em>, and <em>categories</em> keys.
/// All other keys will be used to build the <code>meta</code> property on this object.
/// Example of a dictionary that could be provided to this method:
/// \code
/// [
///   "id": 1,
///   "title": "Hyperion",
///   "price": "18.99",
///   "url": "https://inkrediblebooks.com/hyperion-dan-simmons",
///   "categories": [
///     [ "id": "Sci-Fi", "url": "https://inkrediblebooks.com/categories/scifi" ],
///     [ "id": "Fiction", "url": "https://inkrediblebooks.com/categories/fiction" ]
///   ],
///   "pages": 496
/// ]
///
/// \endcode\param dict The properties for the product
///
+ (void)productAdded:(NSDictionary<NSString *, id> * _Nonnull)dict;
/// Tracks a product added event
/// \param properties The properties for the product
///
+ (void)productAddedWithProperties:(ProductProperties * _Nonnull)properties;
/// Tracks a product removed event
/// The dictionary <em>must</em> have an <em>id</em> key where it’s value is a String or Int. If the <em>id</em> is missing or invalid, the event will not be tracked.
/// This method will attempt to extract the <em>id</em>, <em>title</em>, <em>price</em>, <em>url</em>, and <em>categories</em> keys.
/// All other keys will be used to build the <code>meta</code> property on this object.
/// Example of a dictionary that could be provided to this method:
/// \code
/// [
///   "id": 1,
///   "title": "Hyperion",
///   "price": "18.99",
///   "url": "https://inkrediblebooks.com/hyperion-dan-simmons",
///   "categories": [
///     [ "id": "Sci-Fi", "url": "https://inkrediblebooks.com/categories/scifi" ],
///     [ "id": "Fiction", "url": "https://inkrediblebooks.com/categories/fiction" ]
///   ],
///   "pages": 496
/// ]
///
/// \endcode\param dict The properties for the product
///
+ (void)productRemoved:(NSDictionary<NSString *, id> * _Nonnull)dict;
/// Tracks a product removed event
/// \param properties The properties for the product
///
+ (void)productRemovedWithProperties:(ProductProperties * _Nonnull)properties;
/// Tracks an order completed
/// The dictionary <em>must</em> have a <em>products</em> key as an array, and optionally an <em>id</em> (Int or String) and <em>revenue</em> (Float) keys.
/// Example of a dictionary that could be provided to this method:
/// \code
/// [
///   "id": 1,
///   "revenue": 18.99,
///   "products": [
///     [
///       "title": "Hyperion",
///       "price": 18.99,
///       "quantity": 1,
///       "id": "1",
///       "url": "https://inkrediblebooks.com/hyperion-dan-simmons"
///     ]
///   ]
/// ]
///
/// \endcode\param dict The properties for the product
///
+ (void)orderCompleted:(NSDictionary<NSString *, id> * _Nonnull)dict;
/// Tracks a product added event
/// \param properties The properties for the product
///
+ (void)orderCompletedWithProperties:(OrderCompletedProperties * _Nonnull)properties;
/// Tracks a category viewed event
/// The dictionary <em>must</em> have an <em>id</em> key where it’s value is a String or Int. If the <em>id</em> is missing or invalid, the event will not be tracked.
/// This method will attempt to extract the <em>id</em>, <em>title</em>, and <em>url</em> keys.
/// All other keys will be ignored.
/// Example of a dictionary that could be provided to this method:
/// \code
/// [
///   "id": "mens",
///   "title": "Mens",
///   "url": "https://inkrediblebooks.com/categories/mens"
/// ]
///
/// \endcode\param dict The categories as a dictionary
///
+ (void)categoryViewed:(NSDictionary<NSString *, id> * _Nonnull)dict;
/// Tracks a category viewed event
/// \param category The category to track
///
+ (void)categoryViewedWithCategory:(ProductCategory * _Nonnull)category;
/// Tracks a category viewed event
/// The dictionary <em>must</em> have  <em>query</em> key where it’s value is a String. If the <em>query</em> is missing or invalid, the event will not be tracked.
/// This method will attempt to extract the <em>query</em> and <em>url</em> keys.
/// All other keys will be ignored.
/// Example of a dictionary that could be provided to this method:
/// \code
/// [
///   "query": "hyperion",
///   "url": "https://inkrediblebooks.com/search?q=hyperion"
/// ]
///
/// \endcode\param dict The categories as a dictionary
///
+ (void)productSearched:(NSDictionary<NSString *, id> * _Nonnull)dict;
/// Tracks a product searched event.
/// \param properties The properties for the event
///
+ (void)productSearchedWithProperties:(ProductSearchedProperties * _Nonnull)properties;
/// Attempts to associate events from an anonymous user to the current user.
+ (void)identifyUser:(NSString * _Nonnull)id;
/// Attempts to associate events from an anonymous user to the current user.
/// If you track events without an miu being set, you can later associate those events to a user once they become known.
/// For example, a user uses your app as a guest and you track events. At some point you prompt the user to sign up,
/// and they do. You should call <code>MIClient.setMIU(_:)</code> with the users id, then call <code>MIClient.identifyUser()</code>.
/// note: - This method will attempt to use the current miu value that was previously set via a deeplink or manually by the client
+ (void)identifyUser;
/// Logs a custom event
/// note:
/// Any String in the properties should not exceed 512 characters. Arrays may only contain up to 20 items.
+ (void)logEventWithName:(NSString * _Nonnull)name properties:(NSDictionary<NSString *, id> * _Nonnull)properties;
@end

@class NSURL;
@class NSItemProvider;
@class UISceneConnectionOptions;
@class NSUserActivity;

@interface MIClient (SWIFT_EXTENSION(MovableInk))
/// Checks the Pasteboard to see if there is a URL on it that the SDK can handle when the app is first installed.
/// You should call this if you are utilizing Deferred Deeplinking. Make sure to call this after <code>MIClient.start</code> has
/// been called. You can however, call this anytime you feel is correct for your apps flow (after login / signup) as long
/// <code>MIClient.start</code> has been called. The closure provided when calling start will be called if a link that could be
/// handled was found.
/// If running on iOS 16+, this will prompt the user for permission to read from the pasteboard.
/// If you wish, you can check if your running on iOS 16+ prior to calling this method and let the user know to
/// accept the permission.
/// If you wish to not show the prompt, you can choose to use UIPasteControl instead. If you choose this route, you must
/// set the pasteConfiguration to
/// <code>UIPasteConfiguration(acceptableTypeIdentifiers: [UTType.url.identifier, UTType.text.identifier])</code>.
/// Call <code>MIClient.paste(itemProviders:)</code> from your <code>paste(itemProviders:)</code> method.
/// warning:
/// Do not use both <code>checkPasteboardOnInstall</code> and <code>paste(itemProviders:)</code>
+ (void)checkPasteboardOnInstall;
/// Checks the Pasteboard to see if there is a URL on it that the SDK can handle when the app is first installed.
/// You should call this if you are utilizing Deferred Deeplinking. Make sure to call this after <code>MIClient.start</code> has
/// been called. You can however, call this anytime you feel is correct for your apps flow (after login / signup) as long
/// <code>MIClient.start</code> has been called. This method will not call the closure provided when calling start, but instead
/// will return the resolved url if one was found.
/// If running on iOS 16+, this will prompt the user for permission to read from the pasteboard.
/// If you wish, you can check if your running on iOS 16+ prior to calling this method and let the user know to
/// accept the permission.
/// If you wish to not show the prompt, you can choose to use UIPasteControl instead. If you choose this route, you must
/// set the pasteConfiguration to
/// <code>UIPasteConfiguration(acceptableTypeIdentifiers: [UTType.url.identifier, UTType.text.identifier])</code>.
/// Call <code>MIClient.paste(itemProviders:)</code> from your <code>paste(itemProviders:)</code> method.
/// warning:
/// Do not use both <code>checkPasteboardOnInstall</code> and <code>paste(itemProviders:)</code>
+ (void)checkPasteboardOnInstallWithCompletionHandler:(void (^ _Nonnull)(NSURL * _Nullable))completionHandler;
/// Allows you to send pasted ItemProviders from a UIPasteControl into the SDK to check for deeplinks.
/// If running on iOS 16+, and you wish to not show the paste prompt (checkPasteboardOnInstall);
/// you can choose to use UIPasteControl instead.
/// If you choose this route, you must set the pasteConfiguration to
/// <code>UIPasteConfiguration(acceptableTypeIdentifiers: [UTType.url.identifier, UTType.text.identifier])</code>.
/// Call <code>MIClient.paste(itemProviders:)</code> from your <code>paste(itemProviders:)</code> method.
/// \code
/// override func paste(itemProviders: [NSItemProvider]) {
///   if #available(iOS 16, *) {
///     MIClient.paste(itemProviders: itemProviders)
///   }
/// }
///
/// \endcodeMake sure that <code>MIClient.start</code> has been called before invoking this method.
/// If you need to know if the SDK found a link that could be handled, use the async version of this method instead.
/// warning:
/// Do not use both <code>checkPasteboardOnInstall</code> and <code>paste(itemProviders:)</code>
+ (void)pasteWithItemProviders:(NSArray<NSItemProvider *> * _Nonnull)itemProviders SWIFT_AVAILABILITY(ios,introduced=16);
/// Allows you to send pasted ItemProviders from a UIPasteControl into the SDK to check for deeplinks returning if
/// the SDK found a link that it could handle.
/// If running on iOS 16+, and you wish to not show the paste prompt (checkPasteboardOnInstall);
/// you can choose to use UIPasteControl instead.
/// If you choose this route, you must set the pasteConfiguration to
/// <code>UIPasteConfiguration(acceptableTypeIdentifiers: [UTType.url.identifier, UTType.text.identifier])</code>.
/// Call <code>await MIClient.paste(itemProviders:)</code> from your <code>paste(itemProviders:)</code> method.
/// \code
/// override func paste(itemProviders: [NSItemProvider]) {
///   if #available(iOS 16, *) {
///     Task {
///       let canHandle = await MIClient.paste(itemProviders: itemProviders)
///       // If canHandle is true, the SDK did find a url that it could handle
///       // You can use this to notify the user that the check was successful
///     }
///   }
/// }
///
/// \endcodeMake sure that <code>MIClient.start</code> has been called before invoking this method.
/// warning:
/// Do not use both <code>checkPasteboardOnInstall</code> and <code>paste(itemProviders:)</code>
+ (void)pasteWithItemProviders:(NSArray<NSItemProvider *> * _Nonnull)itemProviders completionHandler:(void (^ _Nonnull)(BOOL))completionHandler SWIFT_AVAILABILITY(ios,introduced=16);
/// Set the paths that the SDK should handle for a given domain.
/// By default, any domains that you ask the MovableInk SDK to handle via the <em>movable_ink_universal_link_domains</em> plist key will allow all paths.
/// If you need to restrict the paths that the SDK should handle, you can set them here. Make sure to only supply domains that you want to restrict.
/// You can supply a dictionary to tell the SDK to handle all paths for the <em>mycustomdomain.com</em> that contain
/// paths with <em>/products/ANY_NUMBER_OF_DIGITS</em>
/// Example
/// \code
/// ["mycustomdomain.com": ["/product/\d+"]]
///
/// \endcodeThe dictionary should contain the domain as a key and the value as an array of regex strings.
/// note:
/// If you call this multiple times with the same domain, the new values will overwrite the old values.
/// warning:
/// It’s a developer error to add your MovableInk domains here.
/// \param options The dictionary of domains and paths
///
+ (void)addHandleablePaths:(NSDictionary<NSString *, NSArray<NSString *> *> * _Nonnull)options;
/// Remove a domain from the handleable paths.
/// \param domain The domain to remove from the handleable paths
///
+ (void)removeHandleablePathsFor:(NSString * _Nonnull)domain;
+ (void)clearHandleablePaths;
/// Register a a list of domains as a deeplink.
/// This should only be the domain of the URL, not the entire URL, i.e: mi.example.com not https://mi.example.com
/// note:
/// You usually wont need to manually call this method yourself as the SDK will do it for you when
/// it attempts to load the domains from your Info.plist. Only call this method yourself if you need to tell the SDK
/// to handle links that you are unaware of at build time.
/// \param domains A list of domains to register with the SDK.
///
+ (void)registerDeeplinkDomains:(NSArray<NSString *> * _Nonnull)domains;
/// Checks a given URL if MovableInk can handle it as a deeplink.
/// \param url A URL to check
///
///
/// returns:
/// True if the URL can be handled by MovableInk, otherwise false.
+ (BOOL)canHandleURL:(NSURL * _Nonnull)url SWIFT_WARN_UNUSED_RESULT;
/// Call this method to handle a Universal Link from incoming UIScene.ConnectionOptions
/// If your application does support Scenes, you should call this method from within
/// your SceneDelegates <code>scene(_:willConnectTo:options:)</code> method. You must also call <code>handleUniversalLink(from:)</code> from the
/// <code>scene(_:continue:)</code> method as well.
/// If your application does <em>not</em> support Scenes, you should utilize <code>handleUniversalLink(from:)</code> method instead.
/// \param options The UIScene.ConnectionOptions
///
+ (BOOL)handleUniversalLinkWith:(UISceneConnectionOptions * _Nonnull)options;
/// Call this method to handle a Universal Link from an incoming NSUserActivity
/// If your application does <em>not</em> support Scenes, you should call this method from within
/// your AppDelegates  <code>application(_:continue:restorationHandler:)</code> method.
/// If your application does support Scenes, you should call this method from within your SceneDelegates <code>scene(_:continue:)</code> method and also
/// should utilize the <code>handleUniversalLink(with:)</code> method.
/// \param userActivity The NSUserActivity Object
///
///
/// returns:
/// True if MIClient can handle the Universal Link, otherwise false.
+ (BOOL)handleUniversalLinkFrom:(NSUserActivity * _Nonnull)userActivity;
/// Call this method to handle a Universal Link from incoming URL.
/// You should call this method in <code>application(_:,open:,options:)</code> method in the AppDelegate or
/// in the <code>onOpenURL</code> modifier for SwiftUI Apps.
/// You can also call this from anywhere else in your app if you need to resolve a link that wasn’t opened via a
/// universal link but still want to process as a Universal Link.
/// \param url A URL to resolve
///
///
/// returns:
/// True if MIClient can handle the Universal Link, otherwise false.
+ (BOOL)handleUniversalLinkWithUrl:(NSURL * _Nonnull)url;
/// Manually resolve a MovableInk Link or some other link, such as an ESP Link, that you want to want to resolve.
/// note:
/// The domain of the url must be registered with the SDK via the plist or <code>registerDeeplinkDomains(_:)</code> prior to this call.
/// warning:
/// Using this method will NOT call the <code>start(launchOptions:deeplinkHandler:)</code> closure.
/// The <code>storedDeeplinkSubject</code> will also NOT be set when using this method.
/// \param url The URL to resolve
///
///
/// returns:
/// The clickthrough URL or nil if there was an error.
+ (void)resolveWithUrl:(NSURL * _Nonnull)url completionHandler:(void (^ _Nonnull)(NSURL * _Nullable, NSError * _Nullable))completionHandler;
@end




SWIFT_CLASS("_TtC10MovableInk21OrderCompletedProduct")
@interface OrderCompletedProduct : NSObject
@property (nonatomic, readonly, copy) NSString * _Nonnull id;
@property (nonatomic, readonly, copy) NSString * _Nullable title;
@property (nonatomic, readonly, copy) NSURL * _Nullable url;
@property (nonatomic, readonly, copy) NSString * _Nullable price;
- (nonnull instancetype)initWithId:(NSString * _Nonnull)id title:(NSString * _Nullable)title price:(NSDecimal)price url:(NSURL * _Nullable)url quantity:(NSInteger)quantity OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithDict:(NSDictionary<NSString *, id> * _Nonnull)dict OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC10MovableInk24OrderCompletedProperties")
@interface OrderCompletedProperties : NSObject
@property (nonatomic, readonly, copy) NSString * _Nullable id;
@property (nonatomic, readonly, copy) NSString * _Nullable revenue;
@property (nonatomic, readonly, copy) NSArray<OrderCompletedProduct *> * _Nonnull products;
- (nonnull instancetype)initWithId:(NSString * _Nullable)id stringRevenue:(NSString * _Nullable)revenue products:(NSArray<OrderCompletedProduct *> * _Nonnull)products OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithId:(NSString * _Nullable)id floatRevenue:(float)revenue products:(NSArray<OrderCompletedProduct *> * _Nonnull)products OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithId:(NSString * _Nullable)id doubleRevenue:(double)revenue products:(NSArray<OrderCompletedProduct *> * _Nonnull)products OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithId:(NSString * _Nullable)id intRevenue:(NSInteger)revenue products:(NSArray<OrderCompletedProduct *> * _Nonnull)products OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithId:(NSString * _Nullable)id decimalRevenue:(NSDecimal)revenue products:(NSArray<OrderCompletedProduct *> * _Nonnull)products OBJC_DESIGNATED_INITIALIZER;
/// Create an instance from a dictionary
/// The dictionary <em>must</em> have an <em>id</em> key where it’s value is a String or Int. If the <em>id</em> is missing or invalid, this will return nil.
/// This method will attempt to extract the <em>id</em>, <em>title</em>, <em>price</em>, <em>url</em>, and <em>categories</em> keys.
/// All other keys will be used to build the <code>meta</code> property on this object.
/// Example of a dictionary that could be provided to this method:
/// \code
/// [
///  "id": 1,
///  "title": "Hyperion",
///  "price": "18.99",
///  "url": "https://inkrediblebooks.com/hyperion-dan-simmons",
///  "categories": [
///    [ "id": "Sci-Fi", "url": "https://inkrediblebooks.com/categories/scifi" ],
///    [ "id": "Fiction", "url": "https://inkrediblebooks.com/categories/fiction" ]
///  ],
///  "pages": 496
/// ]
///
/// \endcode
- (nullable instancetype)initWithDict:(NSDictionary<NSString *, id> * _Nonnull)dict OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC10MovableInk15ProductCategory")
@interface ProductCategory : NSObject
@property (nonatomic, readonly, copy) NSString * _Nonnull id;
@property (nonatomic, readonly, copy) NSString * _Nullable title;
@property (nonatomic, readonly, copy) NSURL * _Nullable url;
- (nonnull instancetype)initWithId:(NSString * _Nonnull)id title:(NSString * _Nullable)title url:(NSURL * _Nullable)url OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithDict:(NSDictionary<NSString *, id> * _Nonnull)dict OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC10MovableInk17ProductProperties")
@interface ProductProperties : NSObject
@property (nonatomic, readonly, copy) NSString * _Nonnull id;
@property (nonatomic, readonly, copy) NSString * _Nullable title;
@property (nonatomic, readonly, copy) NSString * _Nullable price;
@property (nonatomic, readonly, copy) NSURL * _Nullable url;
@property (nonatomic, readonly, copy) NSArray<ProductCategory *> * _Nullable categories;
@property (nonatomic, readonly, copy) NSDictionary<NSString *, id> * _Nullable meta;
- (nonnull instancetype)initWithId:(NSString * _Nonnull)id title:(NSString * _Nullable)title stringPrice:(NSString * _Nullable)price url:(NSURL * _Nullable)url categories:(NSArray<ProductCategory *> * _Nullable)categories meta:(NSDictionary<NSString *, id> * _Nullable)meta OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithId:(NSString * _Nonnull)id title:(NSString * _Nullable)title floatPrice:(float)price url:(NSURL * _Nullable)url categories:(NSArray<ProductCategory *> * _Nullable)categories meta:(NSDictionary<NSString *, id> * _Nullable)meta OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithId:(NSString * _Nonnull)id title:(NSString * _Nullable)title doublePrice:(double)price url:(NSURL * _Nullable)url categories:(NSArray<ProductCategory *> * _Nullable)categories meta:(NSDictionary<NSString *, id> * _Nullable)meta OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithId:(NSString * _Nonnull)id title:(NSString * _Nullable)title intPrice:(NSInteger)price url:(NSURL * _Nullable)url categories:(NSArray<ProductCategory *> * _Nullable)categories meta:(NSDictionary<NSString *, id> * _Nullable)meta OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithId:(NSString * _Nonnull)id title:(NSString * _Nullable)title decimalPrice:(NSDecimal)price url:(NSURL * _Nullable)url categories:(NSArray<ProductCategory *> * _Nullable)categories meta:(NSDictionary<NSString *, id> * _Nullable)meta OBJC_DESIGNATED_INITIALIZER;
/// Create an instance from a dictionary
/// The dictionary <em>must</em> have an <em>id</em> key where it’s value is a String or Int. If the <em>id</em> is missing or invalid, this will return nil.
/// This method will attempt to extract the <em>id</em>, <em>title</em>, <em>price</em>, <em>url</em>, and <em>categories</em> keys.
/// All other keys will be used to build the <code>meta</code> property on this object.
/// Example of a dictionary that could be provided to this method:
/// \code
/// [
///  "id": 1,
///  "title": "Hyperion",
///  "price": 18.99,
///  "url": "https://inkrediblebooks.com/hyperion-dan-simmons",
///  "categories": [
///    [ "id": "Sci-Fi", "url": "https://inkrediblebooks.com/categories/scifi" ],
///    [ "id": "Fiction", "url": "https://inkrediblebooks.com/categories/fiction" ]
///  ],
///  "pages": 496
/// ]
///
/// \endcode
- (nullable instancetype)initWithDict:(NSDictionary<NSString *, id> * _Nonnull)dict OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC10MovableInk25ProductSearchedProperties")
@interface ProductSearchedProperties : NSObject
@property (nonatomic, readonly, copy) NSString * _Nonnull query;
@property (nonatomic, readonly, copy) NSURL * _Nullable url;
- (nonnull instancetype)initWithQuery:(NSString * _Nonnull)query url:(NSURL * _Nullable)url OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithDict:(NSDictionary<NSString *, id> * _Nonnull)dict OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end





#endif
#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#if defined(__cplusplus)
#endif
#pragma clang diagnostic pop
#endif

#else
#error unsupported Swift architecture
#endif
